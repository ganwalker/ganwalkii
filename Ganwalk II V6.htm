<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- Meta tag essencial para responsividade: garante que a largura da viewport se ajuste ao dispositivo -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GANWALK II Visualização Psicodélica</title>
    <!-- Tailwind CSS para estilização rápida e responsiva -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js para a visualização 3D -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Importa as fontes Jacquard 12 e Inter do Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Jacquard+12&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Estilos gerais para o corpo da página */
        body {
            margin: 0;
            overflow: hidden; /* Esconde barras de rolagem */
            background-color: #000; /* Fundo preto */
            font-family: 'Inter', sans-serif; /* Fonte padrão alterada para Inter */
            color: white; /* Cor do texto padrão */
        }
        /* Contêiner principal para a visualização */
        #visualizer-container {
            position: relative;
            width: 100vw; /* Ocupa 100% da largura da viewport, tornando-o responsivo */
            height: 100vh; /* Ocupa 100% da altura da viewport, tornando-o responsivo */
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        /* Estilo para o canvas Three.js */
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%; /* Ocupa 100% da largura do contêiner */
            height: 100%; /* Ocupa 100% da altura do contêiner */
            z-index: 0; /* Fica no fundo */
        }
        /* Estilo para o texto "GANWALK II" */
        #ganwalk-text {
            font-family: 'Jacquard 12', cursive; /* Aplica a fonte Jacquard 12, não alterada */
            font-size: 10vw; /* Tamanho da fonte responsivo (10% da largura da viewport) */
            color: #fff; /* Cor do texto branca, muda com .mustard-theme */
            position: relative;
            z-index: 1; /* Fica acima do canvas */
            pointer-events: none; /* Permite que cliques passem para o canvas abaixo */
            text-align: center;
            line-height: 1; /* Garante que o texto não tenha espaçamento extra */
            transition: text-shadow 0.1s ease-out, transform 0.1s ease, color 0.5s ease; /* Transição suave para o efeito de brilho e transform */
        }
        /* Efeito de brilho neon em tons de cinza para o texto GANWALK II */
        .ganwalk-neon-glow {
            /* Este é o estilo base, a intensidade será ajustada via JS */
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(200, 200, 200, 0.6), 0 0 30px rgba(150, 150, 150, 0.4), 0 0 40px rgba(100, 100, 100, 0.2);
        }

        /* Animação de glitch para o texto GANWALK II */
        @keyframes glitch-effect {
            0% {
                text-shadow: 2px 2px 10px rgba(255, 0, 0, 0.8), -2px -2px 10px rgba(0, 255, 255, 0.6);
                transform: translate(-2px, 2px);
            }
            10% {
                text-shadow: -2px 2px 10px rgba(0, 255, 0, 0.8), 2px -2px 10px rgba(255, 0, 255, 0.6);
                transform: translate(2px, -2px);
            }
            20% {
                text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(200, 200, 200, 0.6); /* Branco */
                transform: translate(0, 0);
            }
            30% {
                text-shadow: 1px -1px 8px rgba(0, 0, 255, 0.7), -1px 1px 8px rgba(255, 255, 0, 0.7);
                transform: translate(1px, -1px);
            }
            40% {
                text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(200, 200, 200, 0.6); /* Branco */
                transform: translate(0, 0);
            }
            50% {
                text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(200, 200, 200, 0.6); /* Branco */
                transform: translate(0, 0);
            }
            60% {
                text-shadow: -1px -1px 10px rgba(255, 100, 0, 0.8), 1px 1px 10px rgba(0, 255, 255, 0.6);
                transform: translate(1px, 1px);
            }
            70% {
                text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(200, 200, 200, 0.6); /* Branco */
                transform: translate(0, 0);
            }
            80% {
                text-shadow: 2px 0 8px rgba(255, 0, 100, 0.7), -2px 0 8px rgba(0, 255, 150, 0.7);
                transform: translate(-2px, 0);
            }
            90% {
                text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(200, 200, 200, 0.6); /* Branco */
                transform: translate(0, 0);
            }
            100% {
                text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(200, 200, 200, 0.6); /* Branco */
                transform: translate(0, 0);
            }
        }

        .ganwalk-glitch {
            animation: glitch-effect 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
        }

        /* Animação para o brilho da palavra "faça" */
        @keyframes faça-flicker {
            0%, 100% {
                text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 20px #fff; /* Branco */
            }
            50% {
                text-shadow: 0 0 2px #fff, 0 0 5px #fff, 0 0 10px #fff; /* Branco */
            }
        }
        .faça-glow {
            text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 20px #fff; /* Branco */
            animation: faça-flicker 2s infinite alternate;
        }

        /* Estilo para a frase "Clique, ouça e faça." */
        #click-to-start-text {
            font-size: 1.5rem;
            color: #fff; /* Cor do texto branca */
            cursor: pointer;
            z-index: 1;
            transition: color 0.3s ease, opacity 0.5s ease;
            opacity: 1;
        }
        #click-to-start-text:hover {
            color: #ccc;
        }

        /* Estilos para a animação de reticências */
        @keyframes ellipsis {
            0% { content: "."; }
            33% { content: ".."; }
            66% { content: "..."; }
        }

        #click-to-start-text.loading {
            pointer-events: none; /* Desabilita cliques durante o carregamento */
            cursor: default;
            color: #777;
        }
        #click-to-start-text.loading::after {
            content: "...";
            animation: ellipsis 1.5s infinite;
            display: inline-block;
            width: 20px; /* Largura para os 3 pontos */
            text-align: left;
        }


        /* Estilo para a barra de controles (reprodutor de música) - Matrix/Cyberpunk */
        #controls-bar {
            position: absolute;
            bottom: 20px; /* 20px do fundo */
            width: 90%; /* Ocupa 100% da largura, responsivo */
            max-width: 800px; /* Largura máxima para desktops, mas se ajusta em telas menores */
            background: rgba(0, 0, 0, 0.8); /* Fundo preto semi-transparente */
            backdrop-filter: blur(10px); /* Efeito de desfoque (Apple-like) */
            border-radius: 0; /* Cantos retos */
            padding: 15px 25px; /* Preenchimento interno */
            display: flex;
            flex-direction: column; /* Organiza os elementos em coluna */
            gap: 15px; /* Espaçamento entre as seções */
            z-index: 2; /* Fica acima de tudo */
            box-shadow: 0 4px 30px rgba(255, 255, 255, 0.5); /* Sombra branca, muda com .mustard-theme */
            border: 1px solid #fff; /* Borda branca, muda com .mustard-theme */
            transition: opacity 0.5s ease, transform 0.5s ease, border-color 0.5s ease, box-shadow 0.5s ease;
        }
        
        #controls-bar.hidden {
            opacity: 0;
            transform: translateY(100%);
            pointer-events: none;
        }


        /* Estilo para a seção de controles principais (play/pause, volume, progresso) */
        .main-controls {
            display: flex;
            align-items: center;
            gap: 20px; /* Espaçamento entre os controles principais */
            flex-wrap: wrap; /* Permite quebrar em telas menores, tornando-o responsivo */
            justify-content: center; /* Centraliza os itens */
            width: 100%; /* Ocupa toda a largura da barra de controle */
        }

        /* Estilo para a barra de progresso */
        .progress-bar-container {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-grow: 3; /* Faz a barra de progresso ocupar mais espaço */
            min-width: 150px; /* Garante uma largura mínima */
        }

        /* Estilo para o tempo de progresso */
        #progress-time-display {
            font-size: 0.8rem;
            color: #fff; /* Cor branca, muda com .mustard-theme */
            white-space: nowrap;
            min-width: 40px; /* Garante que o texto não se movi tanto */
            text-align: right;
            transition: color 0.5s ease;
        }

        /* Estilo para a seção de efeitos */
        .effects-controls {
            display: flex;
            flex-wrap: wrap; /* Permite quebrar em telas menores, tornando-o responsivo */
            justify-content: space-around; /* Distribui os itens uniformemente */
            gap: 15px; /* Espaçamento entre os controles de efeito */
            width: 100%; /* Ocupa toda a largura da barra de controle */
        }

        /* Estilo para cada grupo de controle (label + slider) */
        .control-group {
            display: flex;
            flex-direction: column; /* Padrão: label acima do slider */
            align-items: center;
            gap: 5px;
            min-width: 80px; /* Largura mínima para cada grupo */
            flex-grow: 1; /* Permite que os grupos cresçam para preencher o espaço */
        }

        /* Ajuste para a barra de volume ser menor e o ícone ao lado */
        .control-group.volume-control {
            flex-direction: row; /* Alinha ícone e slider lado a lado */
            align-items: center;
            flex-grow: 1; /* Menor flex-grow para ser menor que a barra de progresso */
            max-width: 150px; /* Limita a largura máxima */
            gap: 5px; /* Espaçamento entre o ícone e o slider */
        }
        .control-group.volume-control input[type="range"] {
            flex-grow: 1; /* Faz o slider ocupar o espaço restante */
        }


        .control-group label {
            font-size: 0.8rem; /* Tamanho da fonte menor para os rótulos */
            color: #fff; /* Cor branca, muda com .mustard-theme */
            white-space: nowrap; /* Evita que o texto quebre */
            transition: color 0.5s ease;
        }
        /* Estilo para sliders (input type="range") */
        input[type="range"] {
            -webkit-appearance: none; /* Remove o estilo padrão do navegador */
            width: 100%;
            height: 8px;
            background: #111; /* Cor da trilha do slider (preto) */
            border-radius: 5px;
            outline: none;
            opacity: 0.8; /* Opacidade padrão */
            transition: opacity .2s; /* Transição suave na opacidade */
        }
        input[type="range"]:hover {
            opacity: 1; /* Aumenta a opacidade ao passar o mouse */
        }
        /* Estilo para o "polegar" (thumb) do slider no WebKit (Chrome, Safari) */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #fff; /* Cor branca, muda com .mustard-theme */
            border-radius: 50%; /* Redondo */
            cursor: pointer;
            box-shadow: 0 0 8px #fff; /* Sombra branca, muda com .mustard-theme */
            transition: background-color 0.5s ease, box-shadow 0.5s ease;
        }
        /* Estilo para o "polegar" (thumb) do slider no Firefox */
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #fff; /* Cor branca, muda com .mustard-theme */
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 8px #fff; /* Sombra branca, muda com .mustard-theme */
            transition: background-color 0.5s ease, box-shadow 0.5s ease;
        }
        /* Estilo para botões de controle (play/pause, volume) */
        button {
            background-color: #000; /* Fundo preto */
            color: #fff; /* Cor do texto branca, muda com .mustard-theme */
            padding: 10px 15px;
            border: 1px solid #fff; /* Borda branca, muda com .mustard-theme */
            border-radius: 10px; /* Cantos arredondados */
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.1s ease, color 0.5s ease, border-color 0.5s ease, box-shadow 0.5s ease; /* Transições suaves */
            box-shadow: 0 0 5px #fff; /* Sombra branca, muda com .mustard-theme */
            display: flex; /* Para centralizar o SVG */
            align-items: center;
            justify-content: center;
        }
        button:hover {
            background-color: rgba(255, 255, 255, 0.1); /* Cor de fundo branca semi-transparente ao passar o mouse, muda com .mustard-theme */
            transform: translateY(-1px); /* Leve movimento para cima */
        }
        button:active {
            transform: translateY(1px); /* Leve movimento para baixo ao clicar */
            box-shadow: none; /* Remove a sombra ao clicar */
        }

        /* Estilo específico para o botão de limpar efeitos */
        #clear-effects-button {
            border-radius: 0;
            box-shadow: none;
        }
        
        /* Estilo para o novo botão de alternância do modo de reprodução */
        #reverse-button {
            border-radius: 50%; /* Torna o botão redondo */
            width: 50px;
            height: 50px;
            padding: 0;
            box-shadow: 0 0 5px rgba(255, 255, 255, 0.5); /* Sombra mais suave */
            background-color: transparent;
        }
        #reverse-button:hover {
            background-color: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        /* Estilo para ícones SVG dentro dos botões */
        button svg {
            fill: #fff; /* Cor do ícone SVG branca, muda com .mustard-theme */
            width: 24px; /* Tamanho do ícone */
            height: 24px;
            transition: fill 0.5s ease;
        }

        /* Estilo para o novo botão de alternância do menu */
        #toggle-controls-button {
            position: fixed; /* Posição fixa na tela */
            bottom: 20px; /* Alinha com a parte inferior do menu */
            left: 50%; /* Centraliza horizontalmente */
            transform: translateX(-50%); /* Ajusta para sua própria largura */
            width: 50px; /* Largura do botão */
            height: 50px; /* Altura do botão */
            background: rgba(0, 0, 0, 0.8); /* Fundo preto semi-transparente */
            backdrop-filter: blur(10px); /* Efeito de desfoque */
            border: 1px solid #fff; /* Borda branca, muda com .mustard-theme */
            border-radius: 50%; /* Torna o botão redondo */
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 3; /* Garante que ele esteja acima do menu */
            box-shadow: 0 0 5px #fff; /* Sombra branca, muda com .mustard-theme */
            transition: opacity 0.5s ease, transform 0.5s ease, border-color 0.5s ease, box-shadow 0.5s ease; /* Transição suave */
        }
        #toggle-controls-button.hidden {
            opacity: 0;
            pointer-events: none; /* Desabilita cliques quando escondido */
        }
        #toggle-controls-button:hover {
            background-color: rgba(255, 255, 255, 0.1); /* Muda com .mustard-theme */
            transform: translateX(-50%) translateY(-2px); /* Leve movimento para cima ao passar o mouse */
        }
        #toggle-controls-button:active {
            transform: translateX(-50%) translateY(0); /* Retorna à posição original ao clicar */
            box-shadow: none;
        }

        /* Estilos da classe .mustard-theme para mudar as cores para amarelo mostarda */
        body.mustard-theme #ganwalk-text {
            color: #E1AD01;
        }
        body.mustard-theme .ganwalk-neon-glow {
            text-shadow: 0 0 10px rgba(225, 173, 1, 0.8), 0 0 20px rgba(225, 173, 1, 0.6), 0 0 30px rgba(225, 173, 1, 0.4), 0 0 40px rgba(225, 173, 1, 0.2);
        }
        body.mustard-theme @keyframes glitch-effect {
            0% { text-shadow: 2px 2px 10px rgba(255, 0, 0, 0.8), -2px -2px 10px rgba(0, 255, 255, 0.6); transform: translate(-2px, 2px); }
            10% { text-shadow: -2px 2px 10px rgba(0, 255, 0, 0.8), 2px -2px 10px rgba(255, 0, 255, 0.6); transform: translate(2px, -2px); }
            20% { text-shadow: 0 0 10px rgba(225, 173, 1, 0.8), 0 0 20px rgba(225, 173, 1, 0.6); transform: translate(0, 0); }
            30% { text-shadow: 1px -1px 8px rgba(0, 0, 255, 0.7), -1px 1px 8px rgba(255, 255, 0, 0.7); transform: translate(1px, -1px); }
            40% { text-shadow: 0 0 10px rgba(225, 173, 1, 0.8), 0 0 20px rgba(225, 173, 1, 0.6); transform: translate(0, 0); }
            50% { text-shadow: 0 0 10px rgba(225, 173, 1, 0.8), 0 0 20px rgba(225, 173, 1, 0.6); transform: translate(0, 0); }
            60% { text-shadow: -1px -1px 10px rgba(255, 100, 0, 0.8), 1px 1px 10px rgba(0, 255, 255, 0.6); transform: translate(1px, 1px); }
            70% { text-shadow: 0 0 10px rgba(225, 173, 1, 0.8), 0 0 20px rgba(225, 173, 1, 0.6); transform: translate(0, 0); }
            80% { text-shadow: 2px 0 8px rgba(255, 0, 100, 0.7), -2px 0 8px rgba(0, 255, 150, 0.7); transform: translate(-2px, 0); }
            90% { text-shadow: 0 0 10px rgba(225, 173, 1, 0.8), 0 0 20px rgba(225, 173, 1, 0.6); transform: translate(0, 0); }
            100% { text-shadow: 0 0 10px rgba(225, 173, 1, 0.8), 0 0 20px rgba(225, 173, 1, 0.6); transform: translate(0, 0); }
        }
        body.mustard-theme @keyframes faça-flicker {
            0%, 100% { text-shadow: 0 0 5px #E1AD01, 0 0 10px #E1AD01, 0 0 20px #E1AD01; }
            50% { text-shadow: 0 0 2px #E1AD01, 0 0 5px #E1AD01, 0 0 10px #E1AD01; }
        }
        body.mustard-theme #controls-bar {
            box-shadow: 0 4px 30px rgba(225, 173, 1, 0.5);
            border: 1px solid #E1AD01;
        }
        body.mustard-theme #progress-time-display,
        body.mustard-theme .control-group label {
            color: #E1AD01;
        }
        body.mustard-theme input[type="range"]::-webkit-slider-thumb {
            background: #E1AD01;
            box-shadow: 0 0 8px #E1AD01;
        }
        body.mustard-theme input[type="range"]::-moz-range-thumb {
            background: #E1AD01;
            box-shadow: 0 0 8px #E1AD01;
        }
        body.mustard-theme button {
            color: #E1AD01;
            border: 1px solid #E1AD01;
            box-shadow: 0 0 5px #E1AD01;
        }
        body.mustard-theme button:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        body.mustard-theme button svg {
            fill: #E1AD01;
        }
        body.mustard-theme #toggle-controls-button {
            border: 1px solid #E1AD01;
            box-shadow: 0 0 5px #E1AD01;
        }
        body.mustard-theme #toggle-controls-button:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        body.mustard-theme #toggle-controls-button svg {
            fill: #E1AD01;
        }
    </style>
</head>
<body>
    <div id="visualizer-container">
        <!-- Texto "GANWALK II" -->
        <div id="ganwalk-text">GANWALK II</div>
        <!-- Frase para iniciar a visualização -->
        <div id="click-to-start-text" class="loading">Áudio carregando</div>
        <!-- Canvas para a renderização 3D do Three.js -->
        <canvas id="visualizerCanvas"></canvas>

        <!-- Barra de controles do reprodutor de música -->
        <div id="controls-bar" class="hidden">
            <!-- Controles principais: Play/Pause, Volume, Progresso e Reverso -->
            <div class="main-controls">
                <button id="play-pause-button">
                    <!-- Ícone SVG de Play -->
                    <svg viewBox="0 0 24 24">
                        <path d="M8 5v14l11-7z"/>
                    </svg>
                </button>
                <!-- NOVO: Botão para alternar entre modo normal e reverso -->
                <button id="reverse-button">
                    <!-- Ícone de reverso fornecido pelo usuário -->
                    <svg xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:xlink="http://www.w3.org/1999/xlink" width="512" height="512" x="0" y="0" viewBox="0 0 612.268 612.268" style="enable-background:new 0 0 512 512" xml:space="preserve" class=""><g><path d="M593.011 382.796H401.785c-10.556 0-19.123 8.567-19.123 19.123s10.001 17.937 18.167 26.083l53.142 53.142c-39.909 33.848-91.387 54.462-147.837 54.462-113.665 0-207.786-82.744-226.029-191.227H2.811c18.855 150.878 147.32 267.717 303.323 267.717 77.58 0 148.296-28.99 202.164-76.624l54.786 54.786c10.308 10.307 19.371 22.01 29.927 22.01s19.123-8.567 19.123-19.123V401.919c0-2.314 0-19.123-19.123-19.123zM19.256 229.471h191.226c10.556 0 19.123-8.567 19.123-19.123s-10.001-17.937-18.167-26.083l-53.142-53.142c39.909-33.847 91.387-54.461 147.837-54.461 113.665 0 207.786 82.744 226.029 191.226h77.293C590.602 117.011 462.136.172 306.134.172c-77.581 0-148.296 28.99-202.164 76.625L49.183 22.01C38.876 11.703 29.812 0 19.256 0S.134 8.567.134 19.123v191.226c0 2.314 0 19.122 19.122 19.122z" fill="#ffffff" opacity="1" data-original="#000000" class=""></path></g></svg>
                </button>
                <div class="progress-bar-container">
                    <input type="range" id="progress-slider" min="0" max="0" step="0.1" value="0">
                    <span id="progress-time-display">0:00</span>
                </div>
                <div class="control-group volume-control">
                    <!-- Ícone SVG para Volume -->
                    <svg id="volume-icon" viewBox="0 0 24 24" width="24" height="24" fill="white">
                        <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.81 5 3.54 5 6.71s-2.11 5.9-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
                    </svg>
                    <input type="range" id="volume-slider" min="0" max="1" step="0.01" value="0.1">
                </div>
            </div>
            <!-- Controles de efeitos de áudio -->
            <div class="effects-controls">
                <div class="control-group">
                    <label for="delay-slider">Eco Profundo</label>
                    <input type="range" id="delay-slider" min="0" max="1" step="0.01" value="0">
                </div>
                <div class="control-group">
                    <label for="reverb-slider">Câmara Etérea</label>
                    <input type="range" id="reverb-slider" min="0" max="1" step="0.01" value="0">
                </div>
                <div class="control-group">
                    <label for="filter-freq-slider">Véu Sonoro</label>
                    <input type="range" id="filter-freq-slider" min="0" max="100" step="1" value="0">
                </div>
                <div class="control-group">
                    <label for="chorus-slider">Coro Astral</label>
                    <input type="range" id="chorus-slider" min="0" max="1" step="0.01" value="0">
                </div>
                <div class="control-group">
                    <label for="overdrive-slider">Distorção Cósmica</label>
                    <input type="range" id="overdrive-slider" min="0" max="1" step="0.01" value="0">
                </div>
                <!-- NOVO EFEITO: Pitch -->
                <div class="control-group">
                    <label for="pitch-slider">Tom</label>
                    <input type="range" id="pitch-slider" min="0.1" max="2" step="0.01" value="1">
                </div>
                <!-- NOVO EFEITO: Equalizador - Graves -->
                <div class="control-group">
                    <label for="low-eq-slider">Graves</label>
                    <input type="range" id="low-eq-slider" min="-20" max="20" step="1" value="0">
                </div>
                <!-- NOVO EFEITO: Equalizador - Médios -->
                <div class="control-group">
                    <label for="mid-eq-slider">Médios</label>
                    <input type="range" id="mid-eq-slider" min="-20" max="20" step="1" value="0">
                </div>
                <!-- NOVO EFEITO: Equalizador - Agudos -->
                <div class="control-group">
                    <label for="high-eq-slider">Agudos</label>
                    <input type="range" id="high-eq-slider" min="-20" max="20" step="1" value="0">
                </div>
            </div>
            <!-- Botão Limpar Efeitos -->
            <button id="clear-effects-button" class="mt-4 px-6 py-3 bg-black border border-white hover:bg-neutral-800 text-white font-semibold">Limpar Efeitos</button>
        </div>

        <!-- NOVO: Botão para mostrar/esconder o menu de controles -->
        <div id="toggle-controls-button" class="hidden">
            <svg id="arrow-icon" viewBox="0 0 24 24" width="24" height="24" fill="white">
                <path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"/>
            </svg>
        </div>
    </div>

    <script>
        // Variáveis globais para Three.js e Web Audio API
        let scene, camera, renderer;
        let audioContext, analyser, sourceNode;
        // Efeitos de áudio
        let gainNode, delayNode, convolverNode, filterNode, overdriveNode, chorusNode, eqNodes;
        let reverbGain, chorusGain; // Variável global para o ganho do reverb e chorus
        
        // Web Audio API: buffers de áudio
        let originalBuffer, reversedBuffer;
        
        // Variáveis para a visualização de linhas e formas
        let visualGroup; // Grupo para conter todas as formas e linhas
        let centralShape; // A forma central (icosaedro)
        let gridGroup; // NOVO: Grupo para conter as linhas da grade
        const gridLines = []; // Array para armazenar as linhas da grade
        let waveLinesGroup; // Grupo para as linhas de onda
        const waveLines = []; // Array para armazenar as linhas de onda

        // Referências aos elementos do DOM
        const clickToStartText = document.getElementById('click-to-start-text');
        const playPauseButton = document.getElementById('play-pause-button');
        const reverseButton = document.getElementById('reverse-button'); // NOVO: Botão de reverso
        const progressSlider = document.getElementById('progress-slider');
        const progressTimeDisplay = document.getElementById('progress-time-display');
        const volumeSlider = document.getElementById('volume-slider');
        const delaySlider = document.getElementById('delay-slider');
        const reverbSlider = document.getElementById('reverb-slider');
        const filterFreqSlider = document.getElementById('filter-freq-slider');
        const chorusSlider = document.getElementById('chorus-slider');
        const overdriveSlider = document.getElementById('overdrive-slider');
        const pitchSlider = document.getElementById('pitch-slider');
        const lowEqSlider = document.getElementById('low-eq-slider');
        const midEqSlider = document.getElementById('mid-eq-slider');
        const highEqSlider = document.getElementById('high-eq-slider');
        const controlsBar = document.getElementById('controls-bar');
        const ganwalkText = document.getElementById('ganwalk-text');
        const volumeIcon = document.getElementById('volume-icon');
        const clearEffectsButton = document.getElementById('clear-effects-button');
        const toggleControlsButton = document.getElementById('toggle-controls-button');

        // Variáveis de estado
        let isPlaying = false;
        let isSeeking = false;
        let colorChangedTriggered = false;
        let isReversed = false;
        let startTime = 0;
        let pausedTime = 0;

        // Definindo a cor amarela mostarda
        const mustardYellowHex = 0xE1AD01;
        const mustardYellowThree = new THREE.Color(mustardYellowHex);
        const whiteThree = new THREE.Color(0xffffff);
        
        // --- Funções de Inicialização ---

        /**
         * Inicializa a cena, câmera, renderizador e elementos visuais do Three.js.
         */
        function initThreeJS() {
            const canvas = document.getElementById('visualizerCanvas');
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 50;
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x000000, 1);

            // Grupo para a visualização principal (icosaedro e linhas de onda)
            visualGroup = new THREE.Group(); 
            visualGroup.position.y = 12;
            scene.add(visualGroup);

            const icosahedronGeometry = new THREE.IcosahedronGeometry(8, 0);
            const icosahedronMaterial = new THREE.MeshBasicMaterial({ color: whiteThree, wireframe: true, transparent: true, opacity: 0 });
            centralShape = new THREE.Mesh(icosahedronGeometry, icosahedronMaterial);
            visualGroup.add(centralShape);

            // NOVO: Grupo para a grade, mantendo-a estática e centralizada
            gridGroup = new THREE.Group();
            gridGroup.position.y = 12;
            scene.add(gridGroup);
            
            const gridSize = 30;
            const lineMaterial = new THREE.LineBasicMaterial({ color: whiteThree, linewidth: 1, transparent: true, opacity: 0 });
            for (let i = 0; i <= gridSize; i++) {
                const points = [];
                for (let j = 0; j <= gridSize; j++) {
                    points.push(new THREE.Vector3(j - gridSize / 2, i - gridSize / 2, 0));
                }
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                geometry.setAttribute('initialPosition', geometry.attributes.position.clone());
                const line = new THREE.Line(geometry, lineMaterial.clone());
                gridGroup.add(line); // Adiciona ao novo grupo da grade
                gridLines.push(line);
            }
            for (let i = 0; i <= gridSize; i++) {
                const points = [];
                for (let j = 0; j <= gridSize; j++) {
                    points.push(new THREE.Vector3(i - gridSize / 2, j - gridSize / 2, 0));
                }
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                geometry.setAttribute('initialPosition', geometry.attributes.position.clone());
                const line = new THREE.Line(geometry, lineMaterial.clone());
                gridGroup.add(line); // Adiciona ao novo grupo da grade
                gridLines.push(line);
            }

            waveLinesGroup = new THREE.Group();
            waveLinesGroup.position.y = -25;
            scene.add(waveLinesGroup);

            const waveLineLength = 70;
            const waveLineResolution = 100;

            const bassLineMaterial = new THREE.LineBasicMaterial({ color: whiteThree, linewidth: 1, transparent: true, opacity: 0 });
            const bassPoints = [];
            for (let j = 0; j <= waveLineResolution; j++) {
                const x = (j / waveLineResolution - 0.5) * waveLineLength;
                bassPoints.push(new THREE.Vector3(x, -1, 0));
            }
            const bassGeometry = new THREE.BufferGeometry().setFromPoints(bassPoints);
            bassGeometry.setAttribute('initialPosition', bassGeometry.attributes.position.clone());
            const bassLine = new THREE.Line(bassGeometry, bassLineMaterial);
            waveLinesGroup.add(bassLine);
            waveLines.push(bassLine);

            const midLineMaterial = new THREE.LineBasicMaterial({ color: whiteThree, linewidth: 1, transparent: true, opacity: 0 });
            const midPoints = [];
            for (let j = 0; j <= waveLineResolution; j++) {
                const x = (j / waveLineResolution - 0.5) * waveLineLength;
                midPoints.push(new THREE.Vector3(x, 0, 0));
            }
            const midGeometry = new THREE.BufferGeometry().setFromPoints(midPoints);
            midGeometry.setAttribute('initialPosition', midGeometry.attributes.position.clone());
            const midLine = new THREE.Line(midGeometry, midLineMaterial);
            waveLinesGroup.add(midLine);
            waveLines.push(midLine);

            const highLineMaterial = new THREE.LineBasicMaterial({ color: whiteThree, linewidth: 1, transparent: true, opacity: 0 });
            const highPoints = [];
            for (let j = 0; j <= waveLineResolution; j++) {
                const x = (j / waveLineResolution - 0.5) * waveLineLength;
                highPoints.push(new THREE.Vector3(x, 1, 0));
            }
            const highGeometry = new THREE.BufferGeometry().setFromPoints(highPoints);
            highGeometry.setAttribute('initialPosition', highGeometry.attributes.position.clone());
            const highLine = new THREE.Line(highGeometry, highLineMaterial);
            waveLinesGroup.add(highLine);
            waveLines.push(highLine);

            window.addEventListener('resize', onWindowResize);
        }

        /**
         * Ajusta o tamanho do renderizador e a proporção da câmera.
         */
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            ganwalkText.style.fontSize = (10 * (window.innerWidth / 100)) + 'px';
        }
        
        /**
         * Inicializa a cadeia de áudio do Web Audio API.
         */
        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
                console.error("Web Audio API não é suportado neste navegador.", e);
                clickToStartText.textContent = "Erro: Web Audio API não suportado.";
                return;
            }

            // Criar nós de áudio
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 256;

            gainNode = audioContext.createGain();
            gainNode.gain.value = 0.1;

            delayNode = audioContext.createDelay(2.0); // 2 segundos de delay máximo
            let feedback = audioContext.createGain();
            feedback.gain.value = 0.5;
            delayNode.delayTime.value = 0;
            delayNode.connect(feedback);
            feedback.connect(delayNode);

            // Reverb com ConvolverNode e uma resposta de impulso
            convolverNode = audioContext.createConvolver();
            convolverNode.buffer = createImpulseResponse(audioContext);
            reverbGain = audioContext.createGain();
            reverbGain.gain.value = 0;

            filterNode = audioContext.createBiquadFilter();
            filterNode.type = "lowpass";
            filterNode.frequency.value = 20000;
            
            overdriveNode = audioContext.createWaveShaper();
            overdriveNode.curve = makeDistortionCurve(0);

            // Chorus com PannerNode e oscilador
            chorusNode = audioContext.createPanner();
            let chorusOsc = audioContext.createOscillator();
            chorusGain = audioContext.createGain();
            chorusGain.gain.value = 0;
            chorusOsc.frequency.value = 4;
            chorusOsc.type = 'sine';
            chorusOsc.connect(chorusGain);
            chorusGain.connect(chorusNode.positionX);
            chorusOsc.start(0);
            
            // Equalizador de 3 bandas
            eqNodes = {
                low: audioContext.createBiquadFilter(),
                mid: audioContext.createBiquadFilter(),
                high: audioContext.createBiquadFilter()
            };
            eqNodes.low.type = "lowshelf";
            eqNodes.low.frequency.value = 320;
            eqNodes.mid.type = "peaking";
            eqNodes.mid.frequency.value = 1000;
            eqNodes.high.type = "highshelf";
            eqNodes.high.frequency.value = 3200;

            // Conectando a cadeia de áudio
            gainNode.connect(eqNodes.low);
            eqNodes.low.connect(eqNodes.mid);
            eqNodes.mid.connect(eqNodes.high);
            eqNodes.high.connect(delayNode);
            eqNodes.high.connect(filterNode);
            eqNodes.high.connect(overdriveNode);
            eqNodes.high.connect(chorusNode);
            eqNodes.high.connect(analyser); // Analisador conectado antes da saída final
            
            // Conexões de efeitos
            delayNode.connect(analyser);
            filterNode.connect(analyser);
            overdriveNode.connect(analyser);
            chorusNode.connect(analyser);
            
            delayNode.connect(audioContext.destination);
            filterNode.connect(audioContext.destination);
            overdriveNode.connect(audioContext.destination);
            chorusNode.connect(audioContext.destination);
            
            // Conexão do Reverb (paralela)
            eqNodes.high.connect(convolverNode);
            convolverNode.connect(reverbGain);
            reverbGain.connect(analyser);
            reverbGain.connect(audioContext.destination);
            
            analyser.connect(audioContext.destination);

            setupEventListeners();
        }

        /**
         * Cria uma curva de distorção para o WaveShaperNode.
         */
        function makeDistortionCurve(amount) {
            let k = typeof amount === 'number' ? amount : 50;
            let n_samples = 44100;
            let curve = new Float32Array(n_samples);
            let deg = Math.PI / 180;
            for (let i = 0; i < n_samples; ++i) {
                let x = i * 2 / n_samples - 1;
                curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
            }
            return curve;
        }

        /**
         * Cria uma resposta de impulso para o Reverb.
         */
        function createImpulseResponse(audioContext) {
            let rate = audioContext.sampleRate;
            let length = 2 * rate;
            let impulse = audioContext.createBuffer(2, length, rate);
            let impulseL = impulse.getChannelData(0);
            let impulseR = impulse.getChannelData(1);
            for (let i = 0; i < length; i++) {
                let n = length - i;
                impulseL[i] = Math.random() * (1 - n / length);
                impulseR[i] = Math.random() * (1 - n / length);
            }
            return impulse;
        }

        /**
         * Carrega a música e cria os buffers de áudio.
         */
        async function loadAudio() {
            try {
                const response = await fetch("https://audio.jukehost.co.uk/JTKWUrfOcCqwJs137wxZ0kNuNfaXaCAK");
                const arrayBuffer = await response.arrayBuffer();
                originalBuffer = await audioContext.decodeAudioData(arrayBuffer);
                reversedBuffer = reverseAudioBuffer(originalBuffer);

                progressSlider.max = originalBuffer.duration;
                updateProgressTime(0); // Garante que a minutagem inicial seja 0:00 / XX:XX
            } catch (error) {
                console.error("Erro ao carregar o áudio:", error);
                clickToStartText.textContent = 'Erro ao carregar áudio';
                clickToStartText.style.color = 'red';
            } finally {
                clickToStartText.classList.remove('loading');
                if (originalBuffer) {
                    clickToStartText.innerHTML = 'Clique, ouça e <span class="faça-glow">faça</span>.';
                    clickToStartText.style.cursor = 'pointer';
                }
            }
        }

        /**
         * Reverte um AudioBuffer.
         */
        function reverseAudioBuffer(buffer) {
            let reversed = audioContext.createBuffer(
                buffer.numberOfChannels,
                buffer.length,
                buffer.sampleRate
            );
            for (let i = 0; i < buffer.numberOfChannels; i++) {
                let originalChannel = buffer.getChannelData(i);
                let reversedChannel = reversed.getChannelData(i);
                for (let j = 0; j < originalChannel.length; j++) {
                    reversedChannel[j] = originalChannel[originalChannel.length - 1 - j];
                }
            }
            return reversed;
        }

        /**
         * Formata segundos para o formato "mm:ss".
         */
        function formatTime(seconds) {
            const safeSeconds = Math.max(0, seconds);
            const minutes = Math.floor(safeSeconds / 60);
            const remainingSeconds = Math.floor(safeSeconds % 60);
            return `${minutes}:${remainingSeconds < 10 ? '0' : ''}${remainingSeconds.toFixed(0)}`;
        }
        
        /**
         * Atualiza o tempo de progresso exibido.
         */
        function updateProgressTime(time) {
            const totalTime = originalBuffer.duration;
            progressTimeDisplay.textContent = `${formatTime(time)} / ${formatTime(totalTime)}`;
        }

        /**
         * Configura todos os event listeners.
         */
        function setupEventListeners() {
            playPauseButton.addEventListener('click', togglePlayPause);
            reverseButton.addEventListener('click', toggleReverse); // NOVO: Listener para o botão de reverso
            clearEffectsButton.addEventListener('click', resetEffects);

            volumeSlider.addEventListener('input', (e) => {
                const gain = parseFloat(e.target.value);
                gainNode.gain.value = gain;
                updateVolumeIcon(gain);
            });
            delaySlider.addEventListener('input', (e) => delayNode.delayTime.value = parseFloat(e.target.value));
            reverbSlider.addEventListener('input', (e) => reverbGain.gain.value = parseFloat(e.target.value));
            
            filterFreqSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                const minFreq = 20;
                const maxFreq = 20000;
                const logFreq = minFreq * Math.pow(maxFreq / minFreq, sliderValue / 100);
                filterNode.frequency.value = logFreq;

                const opacity = (100 - sliderValue) / 100 * 0.6;
                gridLines.forEach(line => line.material.opacity = opacity);
            });

            chorusSlider.addEventListener('input', (e) => {
                const wet = parseFloat(e.target.value);
                chorusGain.gain.value = wet * 10;
            });
            overdriveSlider.addEventListener('input', (e) => overdriveNode.curve = makeDistortionCurve(parseFloat(e.target.value) * 1000));
            pitchSlider.addEventListener('input', (e) => {
                 if (sourceNode) sourceNode.playbackRate.value = parseFloat(e.target.value);
            });
            lowEqSlider.addEventListener('input', (e) => eqNodes.low.gain.value = parseFloat(e.target.value));
            midEqSlider.addEventListener('input', (e) => eqNodes.mid.gain.value = parseFloat(e.target.value));
            highEqSlider.addEventListener('input', (e) => eqNodes.high.gain.value = parseFloat(e.target.value));

            progressSlider.addEventListener('mousedown', () => isSeeking = true);
            
            // Lógica de seek corrigida:
            progressSlider.addEventListener('mouseup', () => {
                isSeeking = false;
                const seekTime = parseFloat(progressSlider.value);
                
                // Pausa o áudio de forma segura, sem acionar o evento 'onended'
                if (isPlaying) {
                    pauseAudio();
                }
                
                // Reinicia a reprodução a partir do novo ponto de busca
                startAudio(seekTime);
                pausedTime = seekTime;
                
                // Atualiza o botão de play/pause
                playPauseButton.innerHTML = `<svg viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>`;
            });
            progressSlider.addEventListener('input', (e) => {
                if (isSeeking) {
                    updateProgressTime(parseFloat(e.target.value));
                }
            });

            // NOVO: Lógica de esconder o menu, corrigida para não esconder ao clicar em controles
            document.addEventListener('click', (event) => {
                // Verifique se o clique foi fora da barra de controles e do botão de alternância
                const isClickOutsideControls = !controlsBar.contains(event.target);
                const isClickOutsideToggleButton = !toggleControlsButton.contains(event.target);
                
                // Só esconda se a barra estiver visível E o clique for fora das áreas de controle
                if (!controlsBar.classList.contains('hidden') && isClickOutsideControls && isClickOutsideToggleButton) {
                    controlsBar.classList.add('hidden');
                    toggleControlsButton.classList.remove('hidden');
                    toggleControlsButton.querySelector('svg path').setAttribute('d', 'M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z');
                    waveLines.forEach(line => line.material.opacity = 0.8);
                }
            });

            toggleControlsButton.addEventListener('click', () => {
                controlsBar.classList.remove('hidden');
                toggleControlsButton.classList.add('hidden');
                waveLines.forEach(line => line.material.opacity = 0);
            });
        }

        /**
         * NOVO: Alterna o modo de reprodução para reverso ou normal.
         */
        function toggleReverse() {
            if (!originalBuffer) return;

            const wasPlaying = isPlaying;
            
            // Pausa o áudio para re-inicializar
            if (wasPlaying) {
                pauseAudio();
            }

            // Alterna a direção
            isReversed = !isReversed;
            
            // Reinicia a reprodução a partir do ponto pausado
            if (wasPlaying) {
                startAudio(pausedTime);
            }
        }
        
        /**
         * Cria e inicia um AudioBufferSourceNode.
         * @param {number} [offset=0] - O tempo de início em segundos (no buffer original).
         */
        function startAudio(offset = 0) {
            if (sourceNode) {
                // Remove o ouvinte de 'onended' antes de parar, para evitar loops indesejados
                sourceNode.onended = null;
                sourceNode.stop();
                sourceNode.disconnect();
                sourceNode = null;
            }
        
            sourceNode = audioContext.createBufferSource();
            // Usa o buffer apropriado (normal ou reverso)
            sourceNode.buffer = isReversed ? reversedBuffer : originalBuffer;
            
            // A taxa de reprodução é sempre positiva para evitar problemas de compatibilidade.
            // A direção do áudio já é controlada pelo buffer.
            sourceNode.playbackRate.value = parseFloat(pitchSlider.value);
            sourceNode.connect(gainNode);

            // Armazena o ponto de início correto no buffer selecionado.
            // Se estiver no modo reverso, o ponto de início é o tempo final menos o offset.
            const bufferOffset = isReversed ? sourceNode.buffer.duration - offset : offset;
            
            sourceNode.start(0, bufferOffset);
            
            // Armazena o tempo de início para o cálculo do progresso.
            startTime = audioContext.currentTime - bufferOffset;
            isPlaying = true;

            // NOVO: Adiciona a lógica de loop que alterna a direção
            sourceNode.onended = () => {
                // Pausa o áudio para garantir que o contexto de áudio esteja limpo para a próxima reprodução
                pauseAudio();
                
                // Alterna o modo de reprodução e reinicia
                isReversed = !isReversed;
                if (isReversed) {
                    // Começa do fim em modo reverso
                    startAudio(originalBuffer.duration);
                } else {
                    // Começa do início em modo normal
                    startAudio(0);
                }
            };
        }

        /**
         * Pausa a reprodução.
         */
        function pauseAudio() {
            if (sourceNode) {
                // Remove o ouvinte 'onended' antes de parar para evitar o loop.
                sourceNode.onended = null;
                sourceNode.stop();
                sourceNode.disconnect();
                sourceNode = null;
            }
            // Calcula o tempo de reprodução decorrido no buffer atual.
            const elapsedTime = audioContext.currentTime - startTime;
            // O tempo pausado é o tempo correspondente no buffer original.
            pausedTime = isReversed ? originalBuffer.duration - elapsedTime : elapsedTime;
            isPlaying = false;
        }

        /**
         * Alterna entre play e pause.
         */
        function togglePlayPause() {
            if (isPlaying) {
                pauseAudio();
                playPauseButton.innerHTML = `<svg viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>`;
            } else {
                startAudio(pausedTime);
                playPauseButton.innerHTML = `<svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>`;
            }
        }
        
        /**
         * Atualiza o ícone de volume.
         */
        function updateVolumeIcon(volume) {
            const iconPath = volume === 0
                ? `<path d="M9 13H7v-2h2v2zm4 0h-2v-2h2v2zm4-2h-2v2h2v-2z"/><path d="M0 0h24v24H0z" fill="none"/>`
                : `<path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.81 5 3.54 5 6.71s-2.11 5.9-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>`;
            volumeIcon.innerHTML = iconPath;
        }

        /**
         * Reseta todos os efeitos de áudio e cores da UI.
         */
        function resetEffects() {
            delaySlider.value = 0;
            reverbSlider.value = 0;
            filterFreqSlider.value = 0;
            chorusSlider.value = 0;
            overdriveSlider.value = 0;
            pitchSlider.value = 1;
            lowEqSlider.value = 0;
            midEqSlider.value = 0;
            highEqSlider.value = 0;
            
            delayNode.delayTime.value = 0;
            reverbGain.gain.value = 0;
            filterNode.frequency.value = 20000;
            chorusGain.gain.value = 0;
            overdriveNode.curve = makeDistortionCurve(0);
            // Corrige o bug: agora a taxa de reprodução do nó de áudio também é redefinida
            if (sourceNode) {
                 sourceNode.playbackRate.value = 1;
            }
            eqNodes.low.gain.value = 0;
            eqNodes.mid.gain.value = 0;
            eqNodes.high.gain.value = 0;
            

            document.body.classList.remove('mustard-theme');
            centralShape.material.color.set(whiteThree);
            centralShape.material.opacity = 1;

            gridLines.forEach(line => {
                line.material.color.set(whiteThree);
                line.material.opacity = 0.6;
                if (line.material.linewidth !== undefined) {
                    line.material.linewidth = 1;
                }
            });
            waveLines.forEach(line => {
                line.material.color.set(whiteThree);
                line.material.opacity = 0.8;
                if (line.material.linewidth !== undefined) {
                    line.material.linewidth = 1;
                }
            });
            colorChangedTriggered = false;
            renderer.setClearColor(0x000000, 1);
        }

        /**
         * Loop principal de animação.
         */
        function animate() {
            requestAnimationFrame(animate);
            let overallAvg = 0;
            let bassAvg = 0;
            let midAvg = 0;
            let highAvg = 0;
            
            // Variável para armazenar o tempo atual do áudio
            let currentTime = 0;

            if (isPlaying && analyser) {
                const data = new Uint8Array(analyser.frequencyBinCount);
                analyser.getByteFrequencyData(data);
                
                let bass = 0, mid = 0, high = 0;
                for (let i = 0; i < data.length; i++) {
                    const amplitude = data[i] / 255;
                    if (i < data.length * 0.1) bass += amplitude;
                    else if (i < data.length * 0.4) mid += amplitude;
                    else high += amplitude;
                }
                bassAvg = bass / (data.length * 0.1);
                midAvg = mid / (data.length * 0.3);
                highAvg = high / (data.length * 0.6);
                overallAvg = (bassAvg + midAvg + highAvg) / 3;

                // Calcula o tempo de reprodução no contexto do áudio original
                const elapsedTime = audioContext.currentTime - startTime;
                currentTime = isReversed ? (originalBuffer.duration - elapsedTime) : elapsedTime;

                // Atualizar barra de progresso
                if (!isSeeking) {
                    progressSlider.value = currentTime;
                    updateProgressTime(currentTime);
                }
            }
            
            // Lógica para a mudança de cor aos 2:06
            const triggerTime = 126; // 2 minutos e 6 segundos = 126 segundos

            if (currentTime >= triggerTime && !colorChangedTriggered) {
                colorChangedTriggered = true;
                document.body.classList.add('mustard-theme');
                centralShape.material.color.set(mustardYellowThree);
                gridLines.forEach(line => line.material.color.set(mustardYellowThree));
                waveLines.forEach(line => line.material.color.set(mustardYellowThree));
            } else if (currentTime < triggerTime && colorChangedTriggered) {
                colorChangedTriggered = false;
                document.body.classList.remove('mustard-theme');
                centralShape.material.color.set(whiteThree);
                gridLines.forEach(line => line.material.color.set(whiteThree));
                waveLines.forEach(line => line.material.color.set(whiteThree));
            }

            const odValue = parseFloat(overdriveSlider.value);
            const reverbValue = parseFloat(reverbSlider.value);
            const chorusValue = parseFloat(chorusSlider.value);
            const delayValue = parseFloat(delaySlider.value);
            const pitchValue = parseFloat(pitchSlider.value);
            const lowEqValue = parseFloat(lowEqSlider.value);
            const midEqValue = parseFloat(midEqSlider.value);
            const highEqValue = parseFloat(highEqSlider.value);
            const direction = isReversed ? -1 : 1;
            
            renderer.setClearColor(0x000000, 1 - (delayValue * 0.9));
            renderer.clear();

            const glowIntensity = 0.8 + overallAvg * 1.2;
            const currentGlowColor = colorChangedTriggered ? mustardYellowHex : 0xFFFFFF;
            const r = (currentGlowColor >> 16) & 0xFF;
            const g = (currentGlowColor >> 8) & 0xFF;
            const b = (currentGlowColor) & 0xFF;
            ganwalkText.style.textShadow = `0 0 ${10*glowIntensity}px rgba(${r}, ${g}, ${b}, 0.8), 0 0 ${20*glowIntensity}px rgba(${r}, ${g}, ${b}, 0.6), 0 0 ${30*glowIntensity}px rgba(${r}, ${g}, ${b}, 0.4)`;
            ganwalkText.style.transform = `scale(${1.0 + overallAvg * 0.05 * direction})`;
            
            // Apenas o icosaedro e as linhas de onda giram
            visualGroup.rotation.y += (0.005 + overallAvg * 0.01) * direction;
            visualGroup.scale.setScalar(1 + delayValue * 0.1);

            centralShape.rotation.x += (0.005 + highAvg * 0.02) * direction; 
            centralShape.rotation.y += (0.005 + midAvg * 0.02) * direction; 
            centralShape.rotation.z += chorusValue * 0.05 * direction;
            centralShape.scale.set(
                1 + bassAvg * 0.5 + odValue * 0.5 + lowEqValue * 0.02,
                1 + bassAvg * 0.5 - odValue * 0.5 + lowEqValue * 0.02,
                1 + bassAvg * 0.5 + odValue * 0.5 + lowEqValue * 0.02
            );
            
            // A grade permanece estática, mas reage ao áudio
            gridLines.forEach(line => {
                const positions = line.geometry.attributes.position.array;
                const initialPositions = line.geometry.attributes.initialPosition.array;
                line.material.linewidth = Math.max(1, 1 + midEqValue * 0.1);
                for (let i = 0; i < positions.length; i += 3) {
                    const x = initialPositions[i];
                    const y = initialPositions[i + 1];
                    let waveEffect = Math.sin(x * 0.5 + currentTime * 2 * direction) * bassAvg * 5 + 
                                       Math.cos(y * 0.5 + currentTime * 3 * direction) * midAvg * 3;
                    const jitterX = (Math.random() - 0.5) * highAvg * 0.8 * (reverbValue * 8 + highEqValue * 0.5) * direction;
                    const jitterY = (Math.random() - 0.5) * highAvg * 0.8 * (reverbValue * 8 + highEqValue * 0.5) * direction;
                    positions[i] = x + jitterX;
                    positions[i + 1] = y + jitterY;
                    positions[i + 2] = waveEffect;
                }
                line.geometry.attributes.position.needsUpdate = true;
            });
            
            if (waveLines[0]) {
                const line = waveLines[0];
                const positions = line.geometry.attributes.position.array;
                const initialPositions = line.geometry.attributes.initialPosition.array;
                line.material.linewidth = Math.max(1, 1 + midEqValue * 0.1);
                for (let i = 0; i < positions.length; i += 3) {
                    const x = initialPositions[i];
                    const waveZ = Math.sin(x * 0.3 + currentTime * 5 * direction) * bassAvg * 25;
                    positions[i + 2] = waveZ;
                }
                line.geometry.attributes.position.needsUpdate = true;
                line.material.opacity = Math.min(1, 0.5 + bassAvg * 0.5);
            }
            if (waveLines[1]) {
                const line = waveLines[1];
                const positions = line.geometry.attributes.position.array;
                const initialPositions = line.geometry.attributes.initialPosition.array;
                line.material.linewidth = Math.max(1, 1 + midEqValue * 0.1);
                for (let i = 0; i < positions.length; i += 3) {
                    const x = initialPositions[i];
                    const waveZ = Math.sin(x * 0.4 + currentTime * 6 * direction) * midAvg * 20;
                    positions[i + 2] = waveZ;
                }
                line.geometry.attributes.position.needsUpdate = true;
                line.material.opacity = Math.min(1, 0.5 + midAvg * 0.5);
            }
            if (waveLines[2]) {
                const line = waveLines[2];
                const positions = line.geometry.attributes.position.array;
                const initialPositions = line.geometry.attributes.initialPosition.array;
                line.material.linewidth = Math.max(1, 1 + midEqValue * 0.1);
                for (let i = 0; i < positions.length; i += 3) {
                    const x = initialPositions[i];
                    const waveZ = Math.sin(x * 0.5 + currentTime * 7 * direction) * highAvg * 15;
                    positions[i + 2] = waveZ;
                }
                line.geometry.attributes.position.needsUpdate = true;
                line.material.opacity = Math.min(1, 0.5 + highAvg * 0.5);
            }

            renderer.render(scene, camera);
        }
        
        // --- Início da Aplicação ---
        clickToStartText.addEventListener('click', async () => {
            if (!originalBuffer) return;
            if (audioContext.state === 'suspended') {
                await audioContext.resume();
            }

            if (isPlaying) return;

            togglePlayPause();
            
            clickToStartText.style.opacity = '0';
            clickToStartText.style['pointer-events'] = 'none';
            controlsBar.classList.remove('hidden');
            toggleControlsButton.classList.add('hidden'); 

            // Torna os elementos visíveis
            centralShape.material.opacity = 1;
            gridLines.forEach(line => line.material.opacity = 0.6);
            waveLines.forEach(line => line.material.opacity = 0.8);
            
            ganwalkText.classList.add('ganwalk-glitch');
            setTimeout(() => {
                ganwalkText.classList.remove('ganwalk-glitch');
                ganwalkText.classList.add('ganwalk-neon-glow');
            }, 600);
        });

        window.onload = async function () {
            initThreeJS();
            initAudio();
            await loadAudio();
            animate();
        };
    </script>
</body>
</html>
